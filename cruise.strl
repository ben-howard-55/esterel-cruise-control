module cruiseMain:

% both requiring signals


% cruiseController signals
input onButton;
input offButton;
input resumeButton;


input Break : float;
input Accel : float;
input speed : float;

% relation Break # Accel;

% cruiseSpeedController signals
input setButton;
input decrementButton;
input incrementButton;

output cruiseSpeed : float;
output cruiseState : string;
output throttleCmd : float;

function regulateThrottle(boolean, float, float) : float;

signal A, B in
signal goingOn in

[
var state := "OFF" : string in

loop
	abort
		loop
			emit cruiseState (state);
			pause;
		end loop
	when onButton;
	
	% immediately turn on
	state := "ON";
	emit goingOn;

	abort
		loop
			trap breakT in
				loop
					trap accT in
						loop
							if (?Break > 3.0f) then
								exit breakT;
							end if;
								
							if (?Accel > 3.0f) then
								exit accT;
							end if;
							
							if (?speed > 150.0f) then
								exit accT;
							end if;
							
							if (?speed < 30.0f) then
								exit accT;
							end if;
							
							% two options to enable
							if (state = "DISABLE") then
								state := "ON";
								emit goingOn;
							end if;
							
							present resumeButton then
								state := "ON";
                                				emit goingOn;
							end present;
							
							if state = "ON" then
								emit A;
							end if;
							
							emit B;
							
							emit cruiseState (state);
							pause;
						end loop
					end trap;
					
					state := "DISABLE";
					emit cruiseState (state);
					emit B;
					pause;
				end loop
			end trap;
			
			state := "STDBY";
			emit cruiseState (state);
			emit B;
			pause;
		
		end loop
	when immediate [offButton];
	
	state := "OFF";
end loop
end var

]
||
[
var state := 0.0f : float in
var goingOnState := false : boolean in
var throttleState := 0.0f : float in

present (speed) then
	state := ?speed;
end present;	

loop
	trap T in
		loop
			present (B) then 
				nothing
			else 
				exit T;
			end present;
			
			present
				case [incrementButton] do
					state := state + 2.5f;
				case [decrementButton] do
					state := state - 2.5f;
				case [setButton] do
					state := ?speed;
			end present;
			
			% need some logic to make sure speed is within boundaries etc..
			if state < 30.0f then
				state := 30.0f;
			end if;
			if state > 150.0f then
				state := 150.0f;
			end if;
			
			% update throttle
			present (A) then 
				nothing
			else 
				exit T;
			end present;
			
			
			% throttle goingOn
			goingOnState := false;
			
			present goingOn then
				goingOnState := true;
			end present;
			
			throttleState := regulateThrottle(goingOnState, state, ?speed);
			emit throttleCmd (throttleState);
								
			emit cruiseSpeed (state);
			pause;
		end loop
		
	end trap;
	
	emit throttleCmd (?Accel);
	
	emit cruiseSpeed (state);
	pause;
end loop
end var
end var
end var
]
end signal
end signal
end module
